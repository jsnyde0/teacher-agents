# app_chainlit.py
# --> Import logging <---
import logging
import os
from typing import List

import chainlit as cl

# --> Import httpx <---
from dotenv import load_dotenv

# --> Import Agent <---
from pydantic_ai import Agent
from pydantic_ai.messages import ModelMessage

# --> Import orchestration functions <---
from src import orchestration

# --> Import AnswerEvaluationResult model <---
from src.agents.answer_evaluator_agent import (
    AnswerEvaluationResult,
)

# Import JCA components
from src.agents.onboarding_agent import OnboardingData

# Import PMA components
from src.agents.pedagogical_master_agent import (
    PedagogicalGuidelines,
)

# Load environment variables (for OpenRouter API Key)
load_dotenv()
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1"
MODEL_NAME = "google/gemini-2.0-flash-lite-001"

# --> Configure logging <---
logging.basicConfig(level=logging.INFO)  # Log INFO and higher messages
logger = logging.getLogger(__name__)


@cl.on_chat_start
async def on_chat_start():
    """
    Initializes agents and conversation history using the orchestration module.
    """
    logger.info("Chat start: Initializing session...")
    if not OPENROUTER_API_KEY:
        logger.error("OPENROUTER_API_KEY not found.")
        await cl.Message(
            content="Error: OPENROUTER_API_KEY not found in environment variables."
        ).send()
        return

    # --> Call orchestration.initialize_agents <---
    agents = await orchestration.initialize_agents(
        api_key=OPENROUTER_API_KEY,
        base_url=OPENROUTER_BASE_URL,
        model_name=MODEL_NAME,
    )

    if not agents:
        logger.error("Agent initialization failed.")
        await cl.Message(content="Error: Failed to initialize agents.").send()
        return

    # Store agents dictionary and initial state in the user session
    # --> Store the whole agents dictionary <---
    cl.user_session.set("agents", agents)
    logger.info(f"Stored agent dictionary in session with keys: {list(agents.keys())}")

    cl.user_session.set("message_history", [])  # Initialize history
    cl.user_session.set("onboarding_data", None)  # To store OA result
    cl.user_session.set("pedagogical_guidelines", None)  # To store PMA result
    cl.user_session.set("learning_plan", None)  # Stores List[str] of steps
    cl.user_session.set("current_step_index", -1)
    cl.user_session.set("current_stage", "onboarding")  # Track current flow stage
    cl.user_session.set("last_teacher_message", None)  # Add last_teacher_message state

    await cl.Message(
        content="Hello! I'm here to help onboard you. To start, could you tell \
            me a bit about what you already know and what you'd like to learn?"
    ).send()


# --> Add Helper Function for Teacher Agent <---
async def run_teacher_for_current_step(
    is_follow_up: bool = False,
    last_user_message: str | None = None,
    answer_evaluation: AnswerEvaluationResult | None = None,
) -> str:
    """Runs the Teacher Agent for the current step and returns the message.

    Constructs a prompt based on whether this is an initial presentation of a step
    or a follow-up responding to the user's last message. Handles retrieving
    necessary context from the user session and includes error handling.

    Args:
        is_follow_up: If True, use a prompt designed for re-engaging the student
                      on the same step after a STAY/UNCLEAR signal, using
                      `last_user_message` for context and feedback.
        last_user_message: The student's previous message content, required when
                         is_follow_up is True to provide context for the response.

    Returns:
        The teaching message string generated by the Teacher Agent, or an error message string
        if generation fails or necessary data is missing.
    """
    # --> Retrieve agents dictionary <---
    agents = cl.user_session.get("agents")
    teacher_agent: Agent = agents.get("teacher_agent")
    learning_plan_steps: List[str] = cl.user_session.get("learning_plan")
    current_step_index: int = cl.user_session.get("current_step_index")
    guidelines_obj: PedagogicalGuidelines = cl.user_session.get(
        "pedagogical_guidelines"
    )

    if (
        not all([teacher_agent, learning_plan_steps, guidelines_obj])
        or current_step_index < 0
    ):
        logger.error("Teacher Agent called with missing session data.")
        return "Error: Could not retrieve necessary data to proceed with teaching."

    if current_step_index >= len(learning_plan_steps):
        logger.error("Teacher Agent called with invalid step index.")
        return "Error: Invalid step index."

    # Get the current step description and guideline string
    current_step_description = learning_plan_steps[current_step_index]
    guideline_str = guidelines_obj.guideline

    # --- Construct prompt conditionally ---
    if not is_follow_up:
        # Standard prompt for introducing a step
        input_prompt = (
            f"Start teaching the student according to these instructions:\\n\\n"
            f"Pedagogical Guideline: {guideline_str}\\n"
            f"Current Learning Step: {current_step_description}\\n\\n"
            f"Introduce this step and immediately provide the first piece of instruction, "
            f"an example, or a guiding question about the topic itself to encourage engagement. "
            f"Do NOT ask generic readiness questions like 'Are you ready?'."
        )
        logger.info(
            f"Running Teacher Agent for step {current_step_index} (initial prompt)."
        )
    else:
        # Follow-up prompt incorporating Answer Evaluation
        if last_user_message is None or answer_evaluation is None:
            logger.error(
                f"Teacher follow-up called for step {current_step_index} without required context (message or evaluation)."
            )
            return "Error: Missing context for follow-up."

        # --> Ensure prompt construction is indented within this else block <---
        input_prompt = f"""**CONTEXT:**
- Current Learning Step Goal: {current_step_description}
- Pedagogical Guideline: {guideline_str}
- Student's Last Message: '{last_user_message}'
- Answer Evaluation: {answer_evaluation.evaluation} (Explanation: {answer_evaluation.explanation})

**Your Task:** Respond conversationally to the 'Student's Last Message' about the 'Current Learning Step Goal'. Your response MUST incorporate the 'Answer Evaluation' and strictly adhere to the 'Pedagogical Guideline'.

1.  **Acknowledge/Feedback:** Briefly acknowledge the student's message, incorporating the provided 'Answer Evaluation' and 'Explanation' naturally into your feedback (e.g., "That's correct because...", "Not quite, the evaluation noted that...", "That's a good question...").
2.  **Guideline-Driven Next Step:** Based on the evaluation and the 'Pedagogical Guideline', provide the *next* small piece of instruction, a clarifying question, a hint, or an example to continue the learning process for the *current* step. The *style* (e.g., Socratic, examples first) MUST match the Guideline.

**IMPORTANT:** Do NOT use step markers. Generate a single, natural conversational response. Do NOT repeat the initial introduction for this step."""

        logger.info(
            f"Running Teacher Agent for step {current_step_index} (follow-up prompt responding to: '{last_user_message[:50]}...' with evaluation: {answer_evaluation.evaluation})"
        )

    # --- Run agent ---
    try:
        result = await teacher_agent.run(input_prompt)  # Run without history for now
        if isinstance(result.data, str):
            return result.data
        else:
            logger.error(
                f"Teacher Agent returned unexpected data type: {type(result.data)}"
            )
            return "Error: Could not generate teaching content for this step."
    except Exception as e:
        logger.error(f"Error running Teacher Agent: {e}", exc_info=True)
        return f"An error occurred while preparing the teaching content: {e}"


@cl.on_message
async def on_message(message: cl.Message):
    """
    Handles incoming user messages, runs the appropriate agent based on state,
    and displays responses.
    """
    # --> Retrieve agents dictionary <---
    agents = cl.user_session.get("agents", {})
    if not agents:
        logger.error("Agents dictionary not found in session. Aborting.")
        await cl.Message(
            content="Critical Error: Session agents missing. Please restart."
        ).send()
        return

    # --> Log session keys at start of message handling <---
    logger.info(
        f"on_message START - Checking session: "
        f" stage='{cl.user_session.get('current_stage')}', "
        f" has_agents={bool(agents)}, "  # Check if agents dict exists
        # Check specific agents within the dict
        f" has_oa={agents.get('onboarding_agent') is not None}, "
        f" has_pma={agents.get('pedagogical_master_agent') is not None}, "
        f" has_jca={agents.get('journey_crafter_agent') is not None}, "
        f" has_teacher={agents.get('teacher_agent') is not None}, "
        f" has_stepeval={agents.get('step_evaluator_agent') is not None}, "
        f" has_anseval={agents.get('answer_evaluator_agent') is not None}"
    )

    current_stage = cl.user_session.get("current_stage", "onboarding")
    message_history: List[ModelMessage] = cl.user_session.get("message_history")

    # If planning is already done, stop
    if current_stage == "complete":
        await cl.Message(
            content="Planning is complete. The next step would be the Teacher Agent."
        ).send()
        return

    # Append user message to history
    # message_history.append(UserPromptPart(content=message.content)) # REMOVED - run method handles current message

    # --- Stage-Based Logic ---

    if current_stage == "onboarding":
        logger.info("Processing message in onboarding stage...")
        # --> Retrieve onboarding_agent from agents dictionary <---
        onboarding_agent: Agent = agents.get("onboarding_agent")
        if not onboarding_agent:
            logger.error("Onboarding Agent not found in session agents dict.")
            await cl.Message(
                content="Error: Cannot process onboarding. Please restart chat."
            ).send()
            # cl.user_session.set("current_stage", "complete") # Let error handling below manage stage
            return

        await cl.Message(content="Processing your information...").send()  # Feedback

        # --> Call orchestration.run_onboarding_step <---
        oa_result, updated_history = await orchestration.run_onboarding_step(
            onboarding_agent=onboarding_agent,
            user_message=message.content,
            message_history=message_history,
        )
        # Update history in session immediately
        cl.user_session.set("message_history", updated_history)

        if isinstance(oa_result, OnboardingData):
            # --- Onboarding Complete: Run Post-Onboarding Pipeline --- #
            logger.info("Onboarding complete. Running post-onboarding pipeline...")
            cl.user_session.set("onboarding_data", oa_result)  # Store onboarding data

            # Retrieve agents needed for pipeline
            pma_agent: Agent = agents.get("pedagogical_master_agent")
            jca_agent: Agent = agents.get("journey_crafter_agent")

            if not pma_agent or not jca_agent:
                logger.error("PMA or JCA agent missing for post-onboarding pipeline.")
                await cl.Message(content="Error: Planning agents not available.").send()
                cl.user_session.set("current_stage", "complete")  # Halt
                return

            await cl.Message(
                content=(
                    "Thanks! I have your onboarding details. Now generating personalized pedagogical guidelines and learning plan..."
                )
            ).send()

            # --> Call orchestration.run_post_onboarding_pipeline <---
            (
                guidelines,
                plan_steps,
                final_history,
                pipeline_error,
            ) = await orchestration.run_post_onboarding_pipeline(
                pma_agent=pma_agent,
                jca_agent=jca_agent,
                onboarding_data=oa_result,
                message_history=updated_history,  # Use history from onboarding step
            )
            # Update history again after pipeline run
            cl.user_session.set("message_history", final_history)

            if pipeline_error:
                # Handle error from PMA or JCA
                logger.error(f"Post-onboarding pipeline failed: {pipeline_error}")
                await cl.Message(
                    content=f"Sorry, I couldn't complete the planning: {pipeline_error}"
                ).send()
                cl.user_session.set("current_stage", "complete")  # End flow on error
            elif guidelines and plan_steps:
                # Pipeline successful
                logger.info(
                    "Post-onboarding pipeline successful. Moving to teaching stage."
                )
                cl.user_session.set("pedagogical_guidelines", guidelines)
                cl.user_session.set("learning_plan", plan_steps)  # Store steps list
                cl.user_session.set("current_step_index", 0)
                cl.user_session.set("current_stage", "teaching")

                await cl.Message(
                    content=(
                        f"**Guideline:** {guidelines.guideline}\\n\\n"
                        f"**Learning Plan:**\\n"
                        + "\\n".join([f"- {s}" for s in plan_steps])
                        + "\\n\\nLet's start with the first step!"
                    )
                ).send()

                # --- Trigger Teacher for Step 0 ---
                # (Uses existing helper for now)
                teaching_message = await run_teacher_for_current_step()
                cl.user_session.set("last_teacher_message", teaching_message)
                await cl.Message(content=teaching_message).send()
            else:
                # Should not happen if pipeline_error is None, but safety check
                logger.error("Post-onboarding pipeline returned unexpected state.")
                await cl.Message(
                    content="Sorry, an unexpected error occurred during planning."
                ).send()
                cl.user_session.set("current_stage", "complete")

        elif isinstance(oa_result, str):
            # Onboarding agent asking for more info
            logger.info("Onboarding agent needs more info.")
            await cl.Message(content=oa_result).send()
        else:
            # Handle onboarding error (oa_result is None)
            logger.error("Onboarding step failed.")
            await cl.Message(
                content="Sorry, something went wrong during onboarding."
            ).send()
            cl.user_session.set("current_stage", "complete")  # End flow

    # --- Teaching Stage Logic ---
    elif current_stage == "teaching":
        logger.info(
            f"Processing message in teaching stage (step {cl.user_session.get('current_step_index')})..."
        )
        # --> Retrieve Step Evaluator Agent from agents dictionary <---
        step_evaluator_agent: Agent = agents.get("step_evaluator_agent")
        # --> Retrieve last teacher message from session <---
        last_teacher_message: str | None = cl.user_session.get("last_teacher_message")

        # Use Step Evaluator to decide next action
        if not step_evaluator_agent:
            logger.error("Step Evaluator Agent not found in session agents dict.")
            await cl.Message(
                content="Error: Cannot evaluate progress. Please restart the chat."
            ).send()
            # cl.user_session.set("current_stage", "complete") # Let error handling manage stage
            return

        # --> Call orchestration.run_step_evaluation <---
        evaluation = await orchestration.run_step_evaluation(
            step_evaluator_agent=step_evaluator_agent,
            last_teacher_message=last_teacher_message,
            user_message=message.content,
        )

        # Check if evaluation failed (returned None)
        if evaluation is None:
            logger.error("Step Evaluation failed.")
            await cl.Message(
                content="Sorry, I had trouble evaluating your progress."
            ).send()
            return  # Stop processing this message if evaluation failed

        if evaluation == "PROCEED":
            current_index = cl.user_session.get("current_step_index")
            learning_plan_steps = cl.user_session.get("learning_plan")  # Get steps list
            next_index = current_index + 1
            cl.user_session.set("current_step_index", next_index)

            if next_index < len(learning_plan_steps):
                logger.info(f"Proceeding to step {next_index}")
                await cl.Message(content="Great! Let's move to the next step.").send()
                # Uses existing helper for now
                teaching_message = await run_teacher_for_current_step()
                # --> Store the teacher message <---
                cl.user_session.set("last_teacher_message", teaching_message)
                await cl.Message(content=teaching_message).send()
            else:
                logger.info("Learning plan complete.")
                await cl.Message(
                    content="Congratulations! You've completed the learning plan."
                ).send()
                cl.user_session.set("current_stage", "complete")

        elif evaluation == "STAY" or evaluation == "UNCLEAR":
            log_level = "STAY" if evaluation == "STAY" else "UNCLEAR"
            logger.info(
                f"Step Evaluator indicates {log_level}. Running Answer Evaluator."
            )

            # --> Call Answer Evaluation Agent via orchestration <---
            answer_evaluator_agent: Agent = agents.get("answer_evaluator_agent")
            learning_plan_steps: List[str] = cl.user_session.get("learning_plan")
            current_step_index: int = cl.user_session.get("current_step_index")

            if not answer_evaluator_agent:
                logger.error("Answer Evaluator agent not found in session agents dict.")
                await cl.Message(
                    content="Error: Cannot evaluate answer context."
                ).send()
                return

            # --> Call orchestration.run_answer_evaluation <---
            answer_evaluation = await orchestration.run_answer_evaluation(
                answer_evaluator_agent=answer_evaluator_agent,
                learning_plan_steps=learning_plan_steps,
                current_step_index=current_step_index,
                last_teacher_message=last_teacher_message,
                user_message=message.content,
            )

            # Check if evaluation failed (returned None)
            if answer_evaluation is None:
                logger.error("Answer Evaluation failed.")
                await cl.Message(
                    content="Sorry, I had trouble evaluating your answer."
                ).send()
                return  # Stop processing this message

            # --> Call Teacher with evaluation result <---
            teaching_message = await run_teacher_for_current_step(
                is_follow_up=True,
                last_user_message=message.content,
                answer_evaluation=answer_evaluation,
            )
            cl.user_session.set("last_teacher_message", teaching_message)
            await cl.Message(content=teaching_message).send()

        else:
            # This case should be less likely now as run_step_evaluation returns None on error/unexpected
            logger.error(f"Step Evaluator returned unexpected value: {evaluation}")
            await cl.Message(
                content="Sorry, I had trouble understanding your response regarding progression."
            ).send()

    elif current_stage == "complete":
        logger.info("Processing message in complete stage.")
        await cl.Message(
            content="Our current learning session is complete. Feel free to start a new chat to learn something else!"
        ).send()

    else:  # Should not happen if stages are managed correctly
        logger.error(f"Reached unexpected stage: {current_stage}")
        await cl.Message(
            content="Sorry, I've encountered an unexpected state. Please restart the chat."
        ).send()

    # Update history at the end of the turn - this was missed before!
    # message_history should be updated within the try block for onboarding agent
    # For teaching, history is not directly used by evaluators/teacher in this pattern,
    # but could be logged or passed if needed in the future.
    # cl.user_session.set("message_history", message_history) # Ensure history is saved if modified
